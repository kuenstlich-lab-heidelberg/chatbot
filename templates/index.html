<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Interface</title>
    <style>
        /* Basic Layout */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 50px;
            background-color: #f0f0f5;
        }

        /* Chat Container */
        .chat-container {
            width: 80%;
            max-width: 600px;
            height: 60vh;
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column-reverse; /* New messages at bottom */
            overflow-y: auto;
            background-color: #ffffff;
        }

        /* Message Bubbles */
        .message {
            display: inline-block;
            padding: 10px 15px;
            border-radius: 15px;
            margin: 8px 0;
            max-width: 70%;
            word-wrap: break-word;
            font-size: 0.9rem;
        }
        
        /* User Message Bubble */
        .message.user {
            background-color: #dcf8c6;
            align-self: flex-end;
            color: #303030;
        }

        /* Bot Message Bubble */
        .message.bot {
            background-color: #f1f0f0;
            align-self: flex-start;
            color: #606060;
        }

        /* Input Area */
        .input-area {
            width: 80%;
            max-width: 600px;
            display: flex;
            margin-top: 10px;
        }

        /* Text Input */
        input[type="text"] {
            flex: 1;
            padding: 10px;
            border-radius: 20px;
            border: 1px solid #ccc;
            font-size: 0.9rem;
        }

        /* Buttons */
        button, #micButton {
            padding: 0 15px;
            margin-left: 8px;
            border-radius: 20px;
            border: none;
            background-color: #34b7f1;
            color: white;
            font-size: 0.9rem;
            cursor: pointer;
        }
        button:active, #micButton:active {
            background-color: #1289c8;
        }

        /* Mic Button */
        #micButton {
            background-color: transparent;
            border: none;
        }

        #micIcon {
            width: 25px;
        }

    </style>
</head>
<body>

<h2>Chat Interface</h2>

<!-- Chat container where messages are displayed -->
<div class="chat-container" id="chatContainer"></div>

<!-- Start Game Button to initialize WebSocket and start the game -->
<button id="startButton" onclick="startGame()">Start Game</button>

<!-- Input area for user messages -->
<div class="input-area" style="display: none;" id="inputArea">
    <input type="text" id="question" placeholder="Type a message..." onkeypress="handleKeyPress(event)">
    <button onclick="sendQuestion()">Send</button>
    <button id="micButton" onclick="toggleRecognition()">
        <img id="micIcon" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Speaker_Icon.svg/512px-Speaker_Icon.svg.png" alt="Mic">
    </button>

</div>

<script>
    let websocket = null;
    let token = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 10;
    let audioContext = null;
    let audioPlayers = {};
    let currentSource = null;  // Reference to the current AudioBufferSourceNode

    let audioQueue = [];  // Queue for audio chunks
    let isPlaying = false;  // Flag to indicate if audio is currently playing
    let accumulatedChunks = [];  // Temporary storage for accumulating chunks
    
    let final_transcript = '';
    let recognizing = false;
    let shouldRestart = false;
    let recognition;
    let inactivityTimeout;  // Timer für Inaktivität
    let sentenceCommitted = false; // Flag, ob Satz finalisiert wurde
    const inactivityTime = 1500; // Zeit in Millisekunden bis Satz abgeschlossen wird


    const chatContainer = document.getElementById("chatContainer");
    const inputArea = document.getElementById("inputArea");
    const startButton = document.getElementById("startButton");

    function handleKeyPress(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            sendQuestion();
        }
    }

    async function sendQuestion() {
        const questionInput = document.getElementById("question");
        const userMessage = questionInput.value.trim();
        questionInput.value = "";

        if (userMessage) {
            addMessage(userMessage, "user");
            try {
                const response = await fetch("/api/chat", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ text: userMessage })
                });

                if (!response.ok) throw new Error(`Server error: ${response.status}`);

                const data = await response.json();
                addMessage(data.response, "bot");
            } catch (error) {
                console.error("Error:", error);
                addMessage("Error connecting to server.", "bot");
            }
        }
    }

    async function startGame() {
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const response = await fetch("/websocket/connect");
            const data = await response.json();
            token = data.token;

            const wsProtocol = window.location.protocol === "https:" ? "wss://" : "ws://";
            const wsUrl = `${wsProtocol}${window.location.host}/websocket/${token}`;
            websocket = new WebSocket(wsUrl);

            websocket.onopen = () => {
                reconnectAttempts = 0;
                toggleChatUI(true);
            };

            websocket.onmessage = async (event) => {
                if (typeof event.data === "string") {
                    try {
                        const message = JSON.parse(event.data);
                        console.log(message)
                        if (message.function === "sound.play_sound") {
                            const soundUrl = `${window.location.protocol}//${window.location.host}/api/audio/${message.file_name}`;
                            const audio = new Audio(soundUrl);
                            audio.loop = message.loop;
                            audioPlayers[message.file_name] = audio;
                            audio.play().catch(error => console.error("Error playing audio:", error));
                        }
                        else if(message.function === "speak.stop"){
                            stopPlayback();
                        }
                    } catch (error) {
                        console.error("Error parsing text message:", error);
                    }
                } else if (event.data instanceof Blob) {
                    const arrayBuffer = await event.data.arrayBuffer();
                    enqueueChunk(arrayBuffer);
                }
            };

            websocket.onerror = (error) => console.error("WebSocket error:", error);
            websocket.onclose = () => reconnectWebSocket();
        } catch (error) {
            console.error("Error initializing WebSocket:", error);
        }
    }

    async function toggleChatUI(show) {
        inputArea.style.display = show ? "flex" : "none";
        startButton.style.display = show ? "none" : "block";

        try {
            inputArea.focus();
            const response = await fetch("/api/chat", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ text: "start" })
            });

            const data = await response.json();
            addMessage(data.response, "bot");
        } catch (error) {
            console.error("Error starting game:", error);
            responseTextarea.value += "Error starting game.\n";
        }
    }

    function reconnectWebSocket() {
        if (reconnectAttempts < maxReconnectAttempts) {
            setTimeout(() => {
                reconnectAttempts++;
                startGame();
            }, 5000);
        } else {
            addMessage("Unable to reconnect WebSocket.", "bot");
        }
    }

    function addMessage(text, sender) {
        const messageBubble = document.createElement("div");
        messageBubble.classList.add("message", sender);
        messageBubble.textContent = text;
        chatContainer.insertBefore(messageBubble, chatContainer.firstChild);
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function enqueueChunk(arrayBuffer) {
        accumulatedChunks.push(new Int16Array(arrayBuffer));

        if (!isPlaying) playNextInQueue();
    }

    function playNextInQueue() {
        if (accumulatedChunks.length === 0) {
            isPlaying = false;
            return;
        }

        const totalLength = accumulatedChunks.reduce((acc, chunk) => acc + chunk.length, 0);
        const concatenatedData = new Int16Array(totalLength);
        let offset = 0;
        for (const chunk of accumulatedChunks) {
            concatenatedData.set(chunk, offset);
            offset += chunk.length;
        }

        accumulatedChunks = [];

        const sampleRate = 24000;
        const audioBuffer = audioContext.createBuffer(1, concatenatedData.length, sampleRate);
        const channelData = audioBuffer.getChannelData(0);
        for (let i = 0; i < concatenatedData.length; i++) {
            channelData[i] = concatenatedData[i] / 32768;
        }

        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);

        source.playbackRate.value = 1.08;
        source.onended = playNextInQueue;
        source.start();

        currentSource = source;
        isPlaying = true;
    }

    function stopPlayback() {
        if (currentSource) {
            currentSource.stop();
            currentSource = null;
        }

        accumulatedChunks = [];
        audioQueue = [];
        isPlaying = false;
    }


    function toggleRecognition() {
      if (recognizing) {
        shouldRestart = false; // Nutzer will manuell stoppen, also kein Neustart
        recognition.stop();
        clearTimeout(inactivityTimeout); // Stoppt den Timer
        console.log("Spracherkennung gestoppt");
      } else {
        final_transcript = '';
        recognition.start();
        shouldRestart = true; // Setze, damit wir wissen, dass wir neu starten wollen
        console.log("Spracherkennung gestartet");
      }
    }



    if (!('webkitSpeechRecognition' in window)) {
      alert("Web Speech API wird von diesem Browser nicht unterstützt. Bitte verwenden Sie Chrome oder einen kompatiblen Browser.");
    } else {
      recognition = new webkitSpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'de-DE'; // Festgelegte Sprache: Deutsch

      recognition.onstart = function() {
        recognizing = true;
      };

      recognition.onerror = function(event) {
        if (event.error === 'no-speech') {
          console.warn("Kein Sprachsignal erkannt. Versuche erneut zu starten.");
        } else if (event.error === 'audio-capture') {
          alert("Kein Mikrofon gefunden. Bitte Mikrofoneinstellungen prüfen.");
        } else if (event.error === 'not-allowed') {
          alert("Mikrofonzugriff verweigert.");
          shouldRestart = false; // Nicht neustarten, wenn Zugriff verweigert wurde
        }
      };

      recognition.onend = function() {
        recognizing = false;
        if (shouldRestart) {
          console.log("Spracherkennung wurde beendet, wird neu gestartet...");
          recognition.start(); // Neustart
        }
      };

      recognition.onresult = function(event) {
        clearTimeout(inactivityTimeout); // Zurücksetzen des Inaktivitäts-Timers
        let interim_transcript = '';

        // Wenn ein neuer Satz beginnt und der vorherige finalisiert war, alles löschen
        if (sentenceCommitted) {
          final_transcript = ''; // Reset finaler Text
          sentenceCommitted = false; // Flag zurücksetzen
        }

        for (let i = event.resultIndex; i < event.results.length; ++i) {
          if (event.results[i].isFinal) {
            // Satz durch `isFinal` beenden, wenn erkannt
            finalizeSentence(event.results[i][0].transcript);
            return; // Beendet die Verarbeitung, wenn `isFinal` gewonnen hat
          } else {
            interim_transcript += event.results[i][0].transcript;
          }
        }

        inputArea.value = interim_transcript;
        
        // Inaktivitäts-Timer neu starten
        inactivityTimeout = setTimeout(() => {
          finalizeSentence(interim_transcript); // Wenn der Timer gewinnt
        }, inactivityTime);
      };
    }

    function finalizeSentence(text) {
      // Einen Punkt hinzufügen und den Satz beenden
      final_transcript = final_transcript.trim() + ' ' + text.trim() + '.';
      inputArea.value = final_transcript;
      sentenceCommitted = true; // Satz wurde finalisiert

      // TTS aufrufen, um den finalisierten Satz vorzulesen
      sendQuestion();

      // Die Spracherkennung anhalten und neu starten
      recognition.stop();
      shouldRestart = true; // Erlaube Neustart nach Stop
    }
</script>

</body>
</html>
