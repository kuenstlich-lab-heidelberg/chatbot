import os
import numpy as np
import threading
from tts.base import BaseTTS
from piper.voice import PiperVoice
from typing import Callable

def get_absolute_path(*relative_parts):
    base_dir = os.path.dirname(os.path.abspath(__file__))
    return os.path.normpath(os.path.join(base_dir, *relative_parts))

class PiperTTS(BaseTTS):
    def __init__(self, audio_sink):
        super().__init__(audio_sink)
        self.model = get_absolute_path("..", "..", "piper_voices", "de_DE-thorsten-high.onnx")
        self.voice = PiperVoice.load(self.model)
        self.sample_rate = self.voice.config.sample_rate
        self.stop_event = threading.Event()
        self.player_stream = None
        self.audio_thread = None
        self.speed = 1.3


    def speak(self, session, text, on_start: Callable = lambda session: None):
        # Ensure any ongoing playback is stopped before starting a new one
        self.stop(session)

        # Clear the stop event
        self.stop_event.clear()

        def play_audio():
            try:

                self.run_callback(on_start, session)
                # Stream audio generated by Piper
                for audio_bytes in self.voice.synthesize_stream_raw(text):
                    # Check stop event after each chunk
                    if self.stop_event.is_set():
                        break
                    # Convert the audio to int16 format for playback
                    audio_data = np.frombuffer(audio_bytes, dtype=np.int16)
                    # Play the audio data immediately
                    self.audio_sink.write(session, audio_data.tobytes())
            except Exception as e:
                print(f"Error in play_audio thread: {e}")

        # Start the playback in a separate thread
        self.audio_thread = threading.Thread(target=play_audio)
        self.audio_thread.start()


    def stop(self, session):
        # Set the stop event to signal the playback thread to stop
        self.stop_event.set()
        
        try:         
            # Wait for the audio thread to finish if it's still running
            if self.audio_thread is not None and self.audio_thread.is_alive():
                self.audio_thread.join()
            self.audio_thread = None
        except Exception as e:
            print(f"Error in stop method: {e}")

